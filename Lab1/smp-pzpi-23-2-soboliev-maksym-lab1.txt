МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
Кафедра «Програмна інженерія»
 
 




ЗВІТ
з практичної роботи №1  
з дисципліни «Скриптові мови програмування»


 



 










Виконав:                                                                                 Прийняв:
ст. гр. ПЗПІ-23-2                                                              ст. викл. Сокорчкук І. П. 
Соболєв М.А.










Харків 2025
1. Мета та завдання роботи
Мета роботи – набуття практичних навичок з розробки комплексних сценаріїв на мові Bash для автоматизації обробки текстових даних у форматі CSV. Закріплення вмінь використання стандартних утиліт UNIX для фільтрації, трансформації та форматування даних.
Завдання роботи:
1. Розробити Bash-скрипт, що перетворює файл розкладу занять, експортований з інформаційної системи CIST у форматі CSV (кодування Windows-1251), у CSV-файл, придатний для імпорту в Google Календар (кодування UTF-8).
2. Реалізувати обробку аргументів командного рядка для запуску в неінтерактивному режимі, включаючи спеціальні ключі (--help, --version, -q/--quiet).
3. Створити інтерактивний режим на базі команди select для вибору вхідного файлу та академічної групи у випадку відсутності аргументів.
4. Забезпечити обробку даних, що включає:
   * Конвертацію кодування файлу з Windows-1251 в UTF-8.
   * Фільтрацію записів за обраною академічною групою.
   * Форматування полів "Тема" та "Опис".
   * Нумерацію однотипних занять.
   * Перетворення формату дати та часу відповідно до вимог Google Календаря.
5. Реалізувати збереження результату у новий файл та виведення у стандартний потік, якщо не активовано "тихий" режим.
6. Передбачити обробку потенційних помилок: відсутність файлу, неможливість читання, відсутність групи у файлі.
2. Теоретичні відомості
Для реалізації завдання було використано конвеєрний підхід та комбінацію стандартних утиліт Bash:
* iconv: Утиліта для перетворення текстових файлів з одного кодування в інше. Використовувалася для конвертації початкового файлу з WINDOWS-1251 (стандартне для експорту з CIST) в універсальне кодування UTF-8.
* sed (Stream Editor): Потоковий текстовий редактор, що дозволяє виконувати операції пошуку та заміни. У скрипті застосовувався для попередньої очистки даних, зокрема для видалення символів лапок ("), що спрощує подальшу обробку полів.
* awk: Потужна мова обробки текстових файлів, орієнтована на роботу з даними, структурованими у вигляді колонок. awk став ядром скрипта, виконуючи основну логіку:
   * Фільтрація рядків за назвою групи ($1 ~ group).
   * Обробка та форматування окремих полів ($1, $2, ..., $12).
   * Використання асоціативних масивів для реалізації лічильника занять (lesson_counts).
   * Форматування дати та часу за допомогою вбудованих функцій split та sprintf.
* grep: Утиліта для пошуку текстових патернів. Використовувалася для видобування назв академічних груп з файлу за допомогою розширених регулярних виразів (-oE).
* sort та uniq: Стандартні команди для сортування рядків та видалення дублікатів. Застосовувалися для створення унікального, відсортованого списку груп для меню select.
* select: Командна конструкція Bash для створення простого нумерованого меню, що дозволяє користувачу робити вибір в інтерактивному режимі.
* tee: Команда, що читає зі стандартного вводу та записує одночасно у стандартний вивід та в один або декілька файлів. Це дозволило одночасно виводити результат на екран та зберігати його у вихідний CSV-файл.
* mapfile (або readarray): Вбудована команда для читання рядків зі стандартного вводу в індексований масив, що зручно для роботи зі списками файлів та груп.
3. Опис програмної реалізації
3.1. Загальна структура та обробка аргументів
Скрипт складається з трьох основних блоків:
1. Блок функцій: print_help, print_version, die для реалізації довідки та обробки помилок.
2. Блок обробки аргументів та інтерактивного режиму:
   * Спочатку скрипт перевіряє наявність ключів --help або --version і, якщо знаходить, виводить відповідну інформацію та завершує роботу.
   * Далі перевіряється ключ тихого режиму (-q або --quiet).
   * Якщо аргументи (назва групи та файл) не були передані при запуску, активується інтерактивний режим.
3.2. Інтерактивний режим
1. Вибір файлу: За допомогою ls та sort формується список доступних .csv файлів, відсортований за датою. Команда select виводить цей список користувачу у вигляді нумерованого меню для вибору.
Вибір групи: Після вибору файлу скрипт аналізує його вміст, щоб знайти всі унікальні назви груп. Для цього використовується конвеєр:
iconv -f WINDOWS-1251 -t UTF-8 "$INPUT_FILE" | sed 's/"//g' | cut -d, -f1 | grep -oE '[А-ЯІЇЄ]{4}-[0-9]{2}-[0-9]{1,2}' | sort | uniq
2. 

Отриманий список груп також виводиться користувачу через меню select. Якщо у файлі знайдено лише одну групу, вона обирається автоматично.
3.3. Основний конвеєр обробки даних
Центральною частиною скрипта є конвеєр команд, що виконує перетворення:
iconv -f WINDOWS-1251 -t UTF-8 "$INPUT_FILE" | sed 's/"//g' | awk -v group="$ACADEM_GROUP" "$AWK_SCRIPT"


   1. iconv перекодовує файл з WINDOWS-1251 в UTF-8.
   2. sed 's/"//g' видаляє всі символи лапок з потоку даних.
   3. awk отримує очищені дані та виконує основну трансформацію за допомогою скрипта, переданого у змінній $AWK_SCRIPT.
3.4. Логіка скрипта awk
   * BEGIN { ... }: Ініціалізує роздільники полів та асоціативний масив lesson_counts для підрахунку номерів занять.
   * NR == 1 { next }: Пропускає перший рядок (заголовок) вхідного файлу.
   * $1 ~ group { ... }: Головний блок, що виконується для кожного рядка, де перше поле ($1) містить назву обраної групи.
   * Обробка теми (Subject): З поля $1 видаляється префікс з назвою групи. Створюється унікальний ключ для масиву lesson_counts, і його значення інкрементується. Фінальна тема формується як "Назва предмету; №N".
   * Форматування дати: Дата з формату DD.MM.YYYY перетворюється на MM/DD/YYYY.
   * Форматування часу: Час з 24-годинного формату HH:MM:SS перетворюється на 12-годинний з індикаторами AM/PM (HH:MM AM/PM).
   * Формування опису (Description): В якості опису береться вміст 12-ї колонки.
   * print: Виводить відформатовані поля у правильній послідовності.
   * END { ... }: Після обробки всіх рядків перевіряє, чи було знайдено хоча б один запис для вказаної групи. Якщо ні (found_count == 0), виводить повідомлення про помилку в stderr та завершує роботу awk з кодом помилки.
4. Результати виконання
4.1. Успішне виконання (інтерактивний режим)
$ ~/soboliev-maksym-task2
Аргументи не задано. Перехід в інтерактивний режим.
1) TimeTable_15_03_2025.csv
Виберіть файл розкладу: 1
Вибрано файл: TimeTable_15_03_2025.csv
1) ПЗПІ-23-1
2) ПЗПІ-23-2
3) ПЗПІ-23-3
Виберіть академічну групу: 1
Вибрано групу: ПЗПІ-23-1
Subject,Start Date,Start Time,End Date,End time,Description
"ПрПА Пз DL ПЗПІ-23-1; №1",03/10/2025,7:45 AM,03/10/2025,9:20 AM,"ПрПА Пз DL ПЗПІ-23-1"
... (інші відформатовані рядки)


Перетворення успішно завершено.
Результат збережено у файлі: Google_TimeTable_15_03_2025.csv


4.2. Виконання з помилкою (групу не знайдено)
$ ~/soboliev-maksym-task2 'ПЗПІ-23-99' TimeTable_15_03_2025.csv
ПОМИЛКА: Групу "ПЗПІ-23-99" не знайдено у файлі.


5. Висновки
Під час виконання лабораторної роботи було розроблено функціональний та надійний Bash-скрипт для вирішення прикладної задачі – конвертації даних. Було успішно застосовано ключові утиліти командного рядка, такі як awk, sed, iconv, grep, sort, uniq та select, об'єднавши їх у єдиний конвеєр обробки.
Особливу увагу було приділено користувацькому досвіду (наявність інтерактивного режиму) та обробці помилок, що є важливим аспектом при розробці будь-яких сценаріїв автоматизації. Скрипт демонструє гнучкість та потужність командної оболонки для вирішення задач, пов'язаних з обробкою текстових файлів різного формату та кодування.
________________
ДОДАТОК А. Код програми
#!/bin/bash


# ==============================================================================
# Скрипт для перетворення розкладу з CIST NURE у формат Google Calendar
# Автор: Maksym Soboliev
# Версія: 1.1.0 (адаптовано до реального формату CSV)
# ==============================================================================


# --- Змінні та константи ---
readonly SCRIPT_NAME=$(basename "$0")
readonly VERSION="1.1.0"
readonly AUTHOR="Maksym Soboliev"
QUIET_MODE=0


# --- Функції ---


# Виводить довідкову інформацію
function print_help() {
  cat << EOF
Usage: $SCRIPT_NAME [--help | --version] | [[-q|--quiet] [group_name] input_cist_file.csv]


Перетворює CSV-файл розкладу з cist.nure.ua у формат для Google Calendar.
Вхідний файл має бути в кодуванні Windows-1251.


Options:
  --help              Вивести цю довідку та вийти.
  --version           Вивести інформацію про версію та вийти.
  -q, --quiet         Тихий режим. Не виводити результат у стандартний потік.


Arguments:
  group_name          Назва академічної групи для фільтрації (напр. 'ПЗПІ-23-1').
  input_cist_file.csv Шлях до вхідного CSV-файлу з розкладом.


Якщо аргументи не вказані, скрипт перейде в інтерактивний режим вибору.
EOF
}


# Виводить інформацію про версію
function print_version() {
  echo "$SCRIPT_NAME version $VERSION"
  echo "Author: $AUTHOR"
}


# Виводить повідомлення про помилку та завершує роботу
function die() {
  echo "ПОМИЛКА: $1" >&2
  exit "${2:-1}"
}


# --- Головний блок обробки ---


# Обробка ключів --help та --version
if [[ "$1" == "--help" ]]; then
  print_help
  exit 0
elif [[ "$1" == "--version" ]]; then
  print_version
  exit 0
fi


# Обробка тихого режиму
if [[ "$1" == "-q" || "$1" == "--quiet" ]]; then
  QUIET_MODE=1
  shift # Зсуваємо аргументи, щоб далі обробляти назву групи та файл
fi


# Визначення вхідних параметрів
ACADEM_GROUP=$1
INPUT_FILE=$2


# --- Інтерактивний режим, якщо параметри не задано ---
if [[ -z "$ACADEM_GROUP" || -z "$INPUT_FILE" ]]; then
  echo "Аргументи не задано. Перехід в інтерактивний режим."


  # 1. Вибір файлу
  PS3="Виберіть файл розкладу: "
  # Знаходимо файли, сортуємо за роком, місяцем, днем
  mapfile -t files < <(ls -1 TimeTable_??_??_20??.csv 2>/dev/null | sort -t_ -k4n -k3n -k2n)
  if [ ${#files[@]} -eq 0 ]; then
    die "У поточній директорії не знайдено файлів розкладу (TimeTable_*.csv)."
  fi


  select INPUT_FILE in "${files[@]}"; do
    if [[ -n "$INPUT_FILE" ]]; then
      echo "Вибрано файл: $INPUT_FILE"
      break
    else
      echo "Неправильний вибір. Спробуйте ще раз."
    fi
  done


  # 2. Вибір групи
  while true; do
    # Генеруємо список унікальних груп з файлу
    # grep -o знаходить усі збіги з шаблоном групи
    mapfile -t groups < <(iconv -f WINDOWS-1251 -t UTF-8 "$INPUT_FILE" 2>/dev/null | sed 's/"//g' | cut -d, -f1 | grep -oE '[А-ЯІЇЄ]{4}-[0-9]{2}-[0-9]{1,2}' | sort | uniq)
    
    if [ ${#groups[@]} -eq 0 ]; then
      die "У файлі '$INPUT_FILE' не знайдено жодної групи, що відповідає шаблону."
    elif [ ${#groups[@]} -eq 1 ]; then
      ACADEM_GROUP=${groups[0]}
      echo "У файлі знайдено лише одну групу: $ACADEM_GROUP. Буде оброблено її."
      break
    else
      PS3="Виберіть академічну групу: "
      select group_choice in "${groups[@]}"; do
        if [[ -n "$group_choice" ]]; then
          ACADEM_GROUP=$group_choice
          echo "Вибрано групу: $ACADEM_GROUP"
          break 2 # Виходимо з обох циклів (select та while)
        else
          echo "Неправильний вибір. Спробуйте ще раз."
        fi
      done
    fi
  done
fi


# Перевірка доступності вхідного файлу
if [ ! -f "$INPUT_FILE" ]; then
  die "Файл '$INPUT_FILE' не знайдено." 2
fi
if [ ! -r "$INPUT_FILE" ]; then
  die "Файл '$INPUT_FILE' недоступний для читання." 3
fi


# Формування імені вихідного файлу
OUTPUT_FILE="Google_$(basename "$INPUT_FILE")"


# --- Основна логіка перетворення файлу ---


# awk-скрипт для обробки даних
AWK_SCRIPT='
BEGIN {
  OFS=","; # Роздільник полів на виході
  FS=",";  # Роздільник полів на вході
  split("", lesson_counts); # Асоціативний масив для лічильників занять
  found_count = 0; # Лічильник знайдених рядків для групи
}
# Пропускаємо перший рядок (заголовок) вхідного файлу
NR == 1 { next }


# Фільтруємо рядки, де в першому полі ($1) є назва нашої групи
$1 ~ group {
  # Поле 1: Тема (Subject)
  subject_raw = $1;
  # Видаляємо назву групи та дефіс на початку
  sub(group " - ", "", subject_raw);
  # Інкрементуємо лічильник для даної теми заняття
  lesson_counts[subject_raw]++;
  final_subject = "\"" subject_raw "; №" lesson_counts[subject_raw] "\"";


  # Поля 2 і 3: Дата та час початку
  start_date_raw = $2;
  start_time_raw = $3;
  split(start_date_raw, d_start, ".");
  start_date = d_start[2] "/" d_start[1] "/" d_start[3];
  
  split(start_time_raw, t_start, ":");
  h_start = t_start[1] + 0;
  ampm_start = (h_start >= 12) ? "PM" : "AM";
  if (h_start > 12) h_start -= 12;
  if (h_start == 0) h_start = 12;
  start_time = sprintf("%d:%s %s", h_start, t_start[2], ampm_start);


  # Поля 4 і 5: Дата та час кінця
  end_date_raw = $4;
  end_time_raw = $5;
  split(end_date_raw, d_end, ".");
  end_date = d_end[2] "/" d_end[1] "/" d_end[3];


  split(end_time_raw, t_end, ":");
  h_end = t_end[1] + 0;
  ampm_end = (h_end >= 12) ? "PM" : "AM";
  if (h_end > 12) h_end -= 12;
  if (h_end == 0) h_end = 12;
  end_time = sprintf("%d:%s %s", h_end, t_end[2], ampm_end);


  # Поле 12: Опис (Description)
  description = "\"" $12 "\"";


  # Виводимо відформатований рядок
  print final_subject, start_date, start_time, end_date, end_time, description;
  found_count++;
}


END {
  # Після обробки файлу перевіряємо, чи було знайдено хоч один запис
  if (found_count == 0) {
    print "ERROR: Групу \"" group "\" не знайдено у файлі." > "/dev/stderr";
    exit 4;
  }
}
'


# Заголовок для Google Calendar CSV
HEADER="Subject,Start Date,Start Time,End Date,End time,Description"


# Виконуємо конвеєр команд, зберігаючи результат
PROCESSING_RESULT=$(iconv -f WINDOWS-1251 -t UTF-8 "$INPUT_FILE" | sed 's/"//g' | awk -v group="$ACADEM_GROUP" "$AWK_SCRIPT")
AWK_EXIT_CODE=$?


# Перевіряємо, чи awk завершився з помилкою
if [ $AWK_EXIT_CODE -ne 0 ]; then
    # Повідомлення про помилку вже виведено awk-скриптом
    exit $AWK_EXIT_CODE
fi


# Створюємо фінальний файл та виводимо на екран (якщо не тихий режим)
(echo "$HEADER"; echo "$PROCESSING_RESULT") | if [ $QUIET_MODE -eq 0 ]; then
    tee "$OUTPUT_FILE"
else
    cat > "$OUTPUT_FILE"
fi


echo -e "\nПеретворення успішно завершено."
echo "Результат збережено у файлі: $OUTPUT_FILE"
exit 0