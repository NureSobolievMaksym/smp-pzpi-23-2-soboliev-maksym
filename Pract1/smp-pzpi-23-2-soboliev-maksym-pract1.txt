МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
Кафедра «Програмна інженерія»
 
 




ЗВІТ
з практичної роботи №1  
з дисципліни «Скриптові мови програмування»


 



 










Виконав:                                                                                 Прийняв:
ст. гр. ПЗПІ-23-2                                                              ст. викл. Сокорчкук І. П. 
Соболєв М.А.












Харків 2025
1. Мета та завдання роботи
Мета роботи – набуття та закріплення практичних навичок розробки скриптів для командного інтерпретатора Bash, включаючи роботу з вхідними параметрами, реалізацію алгоритмів за допомогою різних циклічних та умовних конструкцій, а також структурування коду за допомогою функцій.
Завдання роботи:
1. Розробити Bash-скрипт, що генерує та виводить у стандартний потік виводу ASCII-зображення ялинки.
2. Реалізувати передачу вхідних параметрів (загальна висота та ширина) через аргументи командного рядка.
3. Здійснити валідацію вхідних даних для забезпечення коректності роботи програми.
4. Використати для реалізації алгоритму визначений набір керуючих конструкцій мови Bash: if, while, until, for ... in та for ((...)).
5. Для підвищення модульності коду та уникнення дублювання винести частину логіки в окрему функцію.
6. Забезпечити виведення повідомлень про помилки у стандартний потік помилок (stderr) та завершення роботи скрипту з відповідним кодом повернення.
2. Теоретичні відомості
Для виконання завдання було використано такі засоби та конструкції командного інтерпретатора Bash:
* Командний інтерпретатор Bash (Bourne Again SHell): Стандартна оболонка для більшості дистрибутивів GNU/Linux, що надає потужні засоби для автоматизації завдань за допомогою скриптів.
* Параметри командного рядка: Скрипт отримує доступ до аргументів, переданих при запуску, через спеціальні змінні: $1, $2, ... (позиційні параметри) та $# (кількість переданих параметрів).
* Умовна конструкція if ... then ... else ... fi: Дозволяє виконувати різні блоки коду залежно від істинності умови. У роботі використано розширений синтаксис [[ ... ]], що підтримує, зокрема, перевірку за допомогою регулярних виразів (=~).
* Циклічні конструкції:
   * for ((...)): Арифметичний цикл у C-подібному стилі, зручний для ітерацій з лічильником.
   * for ... in ...: Цикл для ітерації по елементах заданого списку.
   * while ... do ... done: Цикл, що виконується, доки задана умова є істинною.
   * until ... do ... done: Цикл, що виконується, доки задана умова не стане істинною.
* Функції: Дозволяють групувати команди в логічні блоки, які можна викликати повторно. Змінні, оголошені з ключовим словом local, мають область видимості в межах функції.
* Перенаправлення потоків: Механізм, що дозволяє змінювати стандартні джерела вводу/виводу. Конструкція >&2 перенаправляє вивід у стандартний потік помилок (stderr), що є стандартною практикою для повідомлень про помилки.
3. Опис програмної реалізації
3.1. Загальна структура скрипту
Скрипт має чітку логічну структуру:
1. Оголошення функції print_row: Винесена на початок для доступності у головній частині коду.
2. Головний блок:
   * Перевірка та валідація вхідних аргументів.
   * Розрахунок похідних розмірів (висота ярусів, ширина гілок).
   * Перевірка сумісності розрахованих розмірів для можливості побудови симетричної фігури.
   * Послідовний виклик блоків коду для візуалізації ярусів гілок, стовбура та снігу.
3.2. Функція print_row
Для уникнення дублювання коду, що виводить рядок із відступом, було створено функцію print_row.
print_row() {
  local indent_spaces=$1
  local content=$2
  
  for ((i = 0; i < indent_spaces; i++)); do
    echo -n " "
  done


  echo "$content"
}


Функція приймає два аргументи: кількість пробілів для відступу та контент рядка. За допомогою циклу for ((...)) вона друкує необхідну кількість пробілів без переходу на новий рядок (echo -n), після чого виводить сам контент.
3.3. Валідація та розрахунок розмірів
При запуску скрипт виконує низку перевірок:
1. Кількість аргументів має дорівнювати двом (if [ "$#" -ne 2 ]).
2. Аргументи мають бути додатними цілими числами. Це реалізовано за допомогою регулярного виразу: if ! [[ "$VAR" =~ ^[1-9][0-9]*$ ]].
3. Перевірка геометричної сумісності. Це ключова перевірка, яка гарантує, що з наданих висоти та ширини можна побудувати симетричну ялинку за заданими правилами. Висота одного ярусу (TIER_HEIGHT) обчислюється з урахуванням фіксованої висоти стовбура та снігу. Ширина основи трикутника ярусу розраховується за формулою 1 + (TIER_HEIGHT - 1) * 2. Отримане значення має точно дорівнювати ширині снігу мінус два символи. Якщо умова не виконується, побудова неможлива.
3.4. Алгоритм візуалізації
Гілки ялинки: Візуалізація двох ярусів реалізована за допомогою зовнішнього циклу for tier in 1 2. Для малювання кожного ярусу використовується вкладений цикл while, що ітерує по рядках. Усередині нього:
* Визначається символ (* або #) залежно від парності номера рядка.
* Розраховується кількість символів у рядку.
* За допомогою циклу until формується рядок гілок (line_content).
* Викликається функція print_row для виводу рядка з правильним відступом.
Стовбур та сніг: Стовбур та сніг мають фіксовану структуру. Їх візуалізація реалізована за допомогою циклів for ((...)), які друкують відповідні символи потрібну кількість разів.
4. Результати виконання
4.1. Успішне виконання
Запуск скрипту з коректними, сумісними параметрами:
$ ./pzpi-23-2-soboliev-maksym-task1.sh 13 11


Результат виконання:
    *
    ###
   *****
  #######
 *********
     *
    ###
   *****
  #######
 *********
    ###
    ###
***********


4.2. Виконання з помилкою валідації
Запуск скрипту з несумісними параметрами:
$ ./pzpi-23-2-soboliev-maksym-task1.sh 14 12


Результат виконання (повідомлення виводиться у stderr):
Помилка: за вказаними значеннями зобразити симетричну ялинку неможливо.
Спробуйте інші значення. Наприклад, висота 13 та ширина 11.


5. Висновки
У ході виконання лабораторної роботи було успішно розроблено скрипт на мові Bash, що повністю відповідає поставленим вимогам. Було закріплено навички роботи з аргументами командного рядка, реалізовано комплексну логіку валідації вхідних даних та алгоритм генерації ASCII-графіки.
Практичне застосування різних типів циклів (for, while, until) та умовних конструкцій дозволило глибоко зрозуміти їхні переваги та сфери застосування. Використання функції для винесення логіки, що повторюється, продемонструвало свою ефективність у покращенні читабельності та підтримки коду.
Робота підтвердила важливість ретельного проєктування алгоритму та перевірки вхідних даних для створення надійних та коректно працюючих програмних рішень засобами системного скриптингу.
________________
ДОДАТОК А. Код програми


#!/bin/bash


#==============================================================================
# Функція для друку одного рядка з відступом
# Аргументи:
#   $1 - кількість пробілів для відступу зліва
#   $2 - рядок, який потрібно надрукувати
#==============================================================================
print_row() {
  local indent_spaces=$1
  local content=$2


  # Цикл for ((...)) для друку відступу
  for ((i = 0; i < indent_spaces; i++)); do
    echo -n " "
  done


  echo "$content"
}


# --- Головна частина скрипта ---


# 1. Перевірка кількості аргументів
if [ "$#" -ne 2 ]; then
  echo "Помилка: потрібно вказати два параметри: <висота> та <ширина>." >&2
  exit 1
fi


TOTAL_HEIGHT=$1
SNOW_WIDTH=$2


# 2. Валідація аргументів
# Перевіряємо, чи є аргументи додатніми цілими числами.
if ! [[ "$TOTAL_HEIGHT" =~ ^[1-9][0-9]*$ && "$SNOW_WIDTH" =~ ^[1-9][0-9]*$ ]]; then
    echo "Помилка: висота та ширина повинні бути додатніми цілими числами." >&2
    exit 2
fi


# 3. Розрахунок та перевірка можливості побудови ялинки
# Висота для гілок = Загальна висота - висота стовбура (2) - висота снігу (1)
BRANCHES_HEIGHT=$((TOTAL_HEIGHT - 3))
# Максимальна ширина гілок = Ширина снігу - 2
BRANCH_MAX_WIDTH=$((SNOW_WIDTH - 2))


# Перевіряємо, чи достатньо висоти та ширини
if [ "$BRANCHES_HEIGHT" -lt 2 ] || [ "$BRANCH_MAX_WIDTH" -lt 1 ]; then
    echo "Помилка: за вказаними значеннями зобразити ялинку неможливо (замалі розміри)." >&2
    exit 3
fi


# Висота одного ярусу (округлення в меншу сторону через цілочисельну арифметику)
TIER_HEIGHT=$((BRANCHES_HEIGHT / 2))


# Ширина основи трикутника висотою TIER_HEIGHT розраховується як: 1 + (TIER_HEIGHT - 1) * 2
# Ця розрахункова ширина повинна збігатися з дозволеною шириною гілок
CALCULATED_WIDTH=$((1 + (TIER_HEIGHT - 1) * 2))


if [ "$BRANCH_MAX_WIDTH" -ne "$CALCULATED_WIDTH" ]; then
    echo "Помилка: за вказаними значеннями зобразити симетричну ялинку неможливо." >&2
    echo "Спробуйте інші значення. Наприклад, висота 13 та ширина 11." >&2
    exit 4
fi


# --- Малювання ялинки ---


## Гілки ялинки
# Цикл `for ... in` для малювання двох ярусів
for tier in 1 2; do
  row_num=1
  # Цикл `while` для ітерації по рядках одного ярусу
  while [ "$row_num" -le "$TIER_HEIGHT" ]; do
    
    # Визначаємо символ для поточного рядка
    symbol='*'
    if [ $((row_num % 2)) -eq 0 ]; then
        symbol='#'
    fi


    # Розраховуємо кількість символів у поточному рядку
    num_chars=$((1 + (row_num - 1) * 2))
    
    # Формуємо рядок гілок за допомогою циклу `until`
    line_content=""
    count=0
    until [ "$count" -ge "$num_chars" ]; do
      line_content+=$symbol
      count=$((count + 1))
    done


    # Розраховуємо відступ та друкуємо рядок
    indent=$(((SNOW_WIDTH - num_chars) / 2))
    print_row "$indent" "$line_content"


    row_num=$((row_num + 1))
  done
done


# --- Стовбур ялинки ---
# Малюємо стовбур фіксованої висоти (2 рядки) та ширини (3 символи)
TRUNK_WIDTH=3
TRUNK_HEIGHT=2
TRUNK_INDENT=$(((SNOW_WIDTH - TRUNK_WIDTH) / 2))


for ((i = 0; i < TRUNK_HEIGHT; i++)); do
  print_row "$TRUNK_INDENT" "###"
done


# --- Шар снігу ---
# Малюємо сніг фіксованої товщини (1 рядок)
snow_line=""
for ((i = 0; i < SNOW_WIDTH; i++)); do
  snow_line+="*"
done
echo "$snow_line"


exit 0